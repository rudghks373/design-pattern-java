디자인 패턴 자바
====================================

- **Singleton 패턴 : 최대 N개로 객체 생성을 제한하는 패턴**
    - 객체가 너무 많아지면 컴퓨터 자원을 과도하게 사용하게 되고, 이는 프로그램 전체의 속도를 느리게 할 수있다.
    - 객체의 생성을 요청하는 쪽에서 일일이 신경쓰지 않도록 만들어주는 것
    
* * *

- **FlyWeight 패턴 : 큰 자원을 공통으로 사용 할 수 있도록 만드는 패턴**
  - 자원에 대한 비용은 크게 두가지로 나눠 볼 수 있다.
    1.  중복 생성될 가능성이 높은 경우
        -  동일한 자원이 자주 사용될 가능성이 매우 높다는 것을 의미함
    2.  자원 생성 비욘은 큰데 사용 빈도가 낮은 경우
        -  요청이 있을 때에 생성해서 제공해 주는 편이 좋음
  - 자원의 생성을 담당하는 Factory 역할과 관리 역할을 분리하는 것이 좋을 수 있으나, 
    일반적으로 두 역할의 크기가 그리 크지 않아서 하나의 클래스가 담당하도록 구현한다.

* * *

- **Builder 패턴 : 객체를 생성할 때 흔하게 사용하는 패턴**
    - GoF-Design_Pattern의 빌드 패턴
      - 객체의 생성 알고리즘과 조립 방법을 분리하는 것이 목적
    - 이펙티브 자바(Effective-Java)의 빌더 패턴
      - GoF의 빌더 패턴보다 좀 더 코딩 위주의 활용법을 설명
        -   **코드 읽기/유지보수가 편해지도록 빌더 패턴을 쓰라고 한다**
        -   Gof가 책을 썼을 때에는 상대적으로 덜 중요했던 객체 일관성, 
            변경 불가능성 등의 특징을 설명한다
    - **생성자 인자가 많을 때는 빌더 패턴을 적용을 고려하라**
        - 빌더 패턴은 객체 생성을 깔끔하고 유연하게 하기 위한 기법이다.

* * *

- **Observer 패턴 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이가고 
                자동으로 내용이 갱신되는 일대다 의존성을 정의한다**
    - ex) 
      - Subject 객체의 addObserver() 호출해 옵저버로 등록하고 옵저버들은
        Subject 객체의 bCheck 변수의 값이 변경되는지 감시
      - bCheck 변수의 값에 변경되면 update() 메소드에서 
        Subject 의 값이 변경된 것을 감지하고 변경에 따른 필요한 동작을 수행한다.
    - 자바에서는 Observable 인터페이스로 구현가능 
    - 자바 내장 옵저버 패턴 단점과 한계
        - Observable 은 클래스다
            -   Observable이 클래스기 때문에 서브클래스를 만들어야 한다는 점이 문제
            -   수퍼클래스를 확장하고 있는 클래스에 Observable의 기능을 추가 할 수 없어
                재사용성에 제약이 생김
        - Observable 클랫의 핵심 메소드를 외부에서 호출 할 수 없다.
            -   Observable API를 살펴보면 setChanged() 메소드가 protected로 선언
            -   Observable의 서브클래스에만 setChanged() 호출 가능, 결국 직접 어떤
                클래스를 만들고, Observable의 서브클래스를 인스턴스 변수로 사용하는 방법도 쓸 수없다.
                이런 디자인은 상속보다는 구성을 사용한다는 디자인원칙에 위배된다.
        - Androud의 View나 Button등의 위젯의 각종 이벤트를 받을때 쓰인다.
            -   버튼은 항상 클릭이라는 이벤트가 있으며, 이 이벤트는 OnClickListener 라는 인터페이스로
                구성되어있다. 즉 버튼이라는 객체가 Publisher가 되고, OnClickListener가 Observer가 된다고
                볼수 있다. 버튼에서 상태가 변경(클릭) 된다면 OnClickListener로 알려준다.

* * *

- **Adapter 패턴 : 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다**
    -   어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수있다.
    -   Adapter 패턴은 Wrapper 패턴으로 불리기도 한다
        -   일반 상품을 예쁜 포장지로 싸서 선물용 상품으로 만드는 것처럼,
            무엇인가를 한번 포장해서 다른 용도로 사용할 수 있게 교환해주는 것이 wrapper이며 adapter이다
    -   Adapter 패턴에는 다음과 같이 두 가지 종류가 있다.
        -   클래스에 의한 Adapter 패턴 (상속을 사용한 Adapter 패턴)
        -   인스턴스에 의한 Adapter 패턴 (위임을 사용한 Adapter 패턴)
    -   Adapter 패턴은 기존의 클래스를 개조해서 필요한 클래스를 만든다.
        -   이 패턴으로 필요한 메소드를 발빠르게 만들 수 있다.
        -   만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중심적으로
            조사하면 되고, 프로그램 검사도 상당히 쉬워진다.
    -   **Adapter 패턴은 기존의 클래스를 전혀 수정하지 않고 목적한 인터페이스에 맟추려는 것이다**
        -   이미 만들어진 클래스를 새로운 인터페이스에 맞게 개조시킬 때는 당연히 Adapter 패턴을 사용해야한다.  
        -   하지만, 실제 우리가 새로운 인터페이스를 인터페이스에 맞게 개조시킬 때는 기존 클래스의 소스를 바꾸어서 '수정' 하려고 한다.
        -   조금만 수정하면 작업은 끝이라고 생각하기 쉽지만, 기존의 클래스를 수정한 후에 다시 한번 테스트 해야 한다.
        -   테스트가 끝낸 검증된 인터페이스를 수정하지 않도록 하는 것이 Adapter 패턴의 주 목적이다.
    
    `관련패턴`
    
    **Bridge 패턴**
    -   Adapter 패턴은 인터페이스가 서로 다른 클래스들을 연결하는 패턴이다.
    -   Bridge 패턴은 기능의 계층과 구현의 계층을 연결하는 패턴이다.
    
    **Decorator 패턴**
    -   Adapter  패턴은 인터페이스의 차이를 조정하기 위한 패턴이다.
    -   Decorator 패턴은 인터페이스를 수정하지 않고, 기능을 추가하는 패턴이다.
    
* * *

- **Facade 패턴 : 하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스를 정의**
    -   Facade 패턴은 어댑터 패턴과 거의 같은 방식으로 작동하지만 서로 다른 목적이 있다.
        -   Adapter 패턴은 원래 코드를 다른 코드와 작동할 수 있는 래퍼를 제공한다.
        -   Facade 패턴은 원래 코드를더 쉽게 처리 할 수 있는 래퍼를 제공한다.
    -   Facade 패턴은 오브젝트나 클래스 인터페이스가 작동하기에 너무 어려울 경우,
        쉽게 사용 할 수 있는 프론트엔드 인터페이스를 제공한다.
        -   캡슐화되지 않은 코드를 처리 할 때 Facade 패턴을 사용한다.
        -   원하는 코드를 다시 작성할 수 없을 때 일반적으로 Facade 패턴을 사용한다.
            -   Facade를 사용하면 문제를 해결 할 수 있지만 기본코드가 변경되면 Facade 패턴도 변경해야 한다.

